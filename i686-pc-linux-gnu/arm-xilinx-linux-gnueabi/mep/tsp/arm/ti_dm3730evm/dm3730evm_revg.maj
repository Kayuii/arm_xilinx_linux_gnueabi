+q  // Enter quiet mode
//___________________________________________________________________
//
//               Copyright (c) 2011 Mentor Graphics Corporation
//                           All rights reserved
//
//   THIS WORK CONTAINS TRADE SECRETS AND PROPRIETARY INFORMATION WHICH IS
//    THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS
//                        SUBJECT TO LICENSE TERMS.
//
//___________________________________________________________________
//
// Mentor Embedded Sourcery Probe target initialization file for the
// ______________ reference platform.  It supports this platform as-is,
// and can be adapted to a new target based on this reference board,
// as detailed below.  For a brand new custom board not related to
// this reference board, it may be better to start from the template
// rather than trying to adapt this file.
//
// Target Description (to be filled in):
//
//     Board:   Mistral TMDSEVM3730 rev.G (AM/DM37xxEVM)
//     Device:  TI DM3730
//     CPU ID:  Cortex-A8
//     Endian:  Little
//
// Porting Guide:
//
// The user should make the following adaptations to port this file
// to a new target board based on the associated reference platform:
//
//        0. Review the MEP Probe Initialization section at
//           "TO DO #0" below to make sure the settings are
//           right for your board.
//        1. Update the memory configuration table for changes
//           in the new board's  *Physical*  memory map.  See
//           'TO DO #1' below.
//        2. If your target board requires any special MEP
//           settings, they should be added to the end of the
//           ONE_TIME_SETUP section.  See 'TO DO #2' below.
//        3. Decide whether the target should be automatically
//           reset and/or initialized upon start-up by choosing
//           the desired command at 'TO DO #3' below.  This
//           really depends on your use case.
//        4. If the board has no boot code (or bad boot code),
//           and you want to download into RAM, then you may
//           have to adapt the memory controller initialization
//           script at 'TO DO #4' below to account for changes
//           relative to the reference platform.
//        5. If you care about programming your target's NOR
//           Flash, then review the Flash Initialization section at
//           "TO DO #5" below to add any special flash unlock code
//           that may be needed.
//
// NOTE:  Additional information on MON commands and the configuration
//        options used here is available in the online help system.
//___________________________________________________________________
dv "Reading $$# ...\n"


// Initialization script preparation
// =================================

// The RTI, RTNI, and TI command aliases call script functions in this file.
// These command aliases should never be changed.

ea RTI   $$#.DO_RTI  // RTI  call DO_RTI script function  (Reset Target and Initialize)
ea RTNI  $$#.DO_RTNI // RTNI call DO_RTNI script function (Reset Target with No Initialization)
ea TI    $$#.DO_TI   // TI   call DO_TI script function   (Target Initialize without resetting)


// MEP Probe Initialization
// ==========================

// TO DO #0 -- Review the following MEP configuration options to make
//             sure they are right for your target board hardware and
//             processor device design.

// The  Trgt_Resets_JTAG  option informs the MEP probe whether the target
// board will forward a system reset (nSRST) to the JTAG interface (nTRST),
// or reset the system only without resetting the JTAG interface.  When in
// doubt, a YES setting is safer.  When the two reset circuits are known
// to be independent, which is strongly recommended, then a NO setting is
// recommended.

eo Trgt_Resets_JTAG  = yes

// The  Ice_JTAG_Use_RTCLK  and  Ice_JTAG_Clock_Freq  options are related
// and must be considered together.  An  Ice_JTAG_Use_RTCLK  setting of
// ON  selects adaptive clocking mode, where the JTAG clock is dynamically
// controlled by the target processor.  When  Ice_JTAG_Use_RTCLK  is set
// OFF  then normal (unthrottled) clocking is selected.
//
// When adaptive clocking is disabled, the  Ice_JTAG_Clock_Freq  option
// specifies the the JTAG clock (TCK) frequency in Megahertz, from
// 0.002 to 100 (depending on probe hardware capability).  A lower setting
// is safer, a higher setting yields higher performance.  Note that the
// requested frequency will be adjusted down to the closest frequency
// supported by the probe hardware (displaying this option will show the
// actual TCK frequency).
//
//     IJUR  Clock mode
//     ====  ========================
//     OFF   Free running TCK at specified frequency (RTCK is ignored)
//     ON    Adaptive clocking with frequency controlled by RTCK
//           (Ice_JTAG_Clock_Freq is ignored)
//
// For Virtual MESP, both options should be removed.
//
// Note that enabling  Ice_JTAG_Use_RTCLK  on target boards that do not
// drive the RTCK signal will lock up the JTAG interface.

eo Ice_JTAG_Use_RTCLK  = off
eo Ice_JTAG_Clock_Freq = 12.5
if (@$Ice_JTAG_Use_RTCLK) {doq Ice_JTAG_Use_RTCLK} {doq Ice_JTAG_Clock_Freq}

// The following command can be used to define the details of the JTAG
// daisy chain.  It is only required for targets on which the MEP
// auto-detection algorithm cannot correctly determine the JTAG connection
// details.  On most boards this command can be omitted.
//
//    ew MEP_JTAG_DIMENSION = TAP_CNT, IR1_CNT [ , IR2_CNT ]  ...

ew MEP_JTAG_DIMENSION = 2, 4, 6

// The following commands can be used to define special JTAG initialization
// operations required by certain processors.  The first one, if defined,
// is scanned in right after the JTAG reset cycle completes, but before the
// standard JTAG initialization performed by the MEP.  The second, if
// defined, is scanned in right after the standard JTAG initialization
// performed by the MEP.  On most boards these can both be omitted.
//
//    ew MEP_JTAG_INIT0 = <scan-op> [ , <scan-op> ]  ...
//    ew MEP_JTAG_INIT1 = <scan-op> [ , <scan-op> ]  ...

ew MEP_JTAG_INIT0 =   89000006, 00000007, 09000008, 00000089, 89000006, 00000002, 09000020, 81000080, 09000020, a3002048, 09000020, 81000081, 09000020, a3002148, 81000006, 0000003f, 81000010, ffff

// The  Core_Access_Select  option selects which core to assiciate with this
// debug connection on devices which have multiple cores that are accessed
// via the same TAP. This option needs to be set only for certain processors
// e.g. multi-core Cortex-A9. On other boards this command should be omitted.
// When set to 0, no CPU core is attached to the debug connection. When set
// to 1..N, the debug connection is associated with the selected core.  The
// default value of this option is 1 if there is a single core, or 0 if there
// are multiple cores, in which case the following command must be set to
// select the desired core. Normally this setting is configured as part of
// a launch setup, but can be overridden here.
//
// eo Core_Access_Select = 1

// The  Ice_Power_Sense  option enables the target power monitor.  When
// target power is detected, the debug interface is enabled.

eo Ice_Power_Sense = VREF

// The  Ice_JTAG_TAP_Select  option controls which TAP on a multi-TAP
// daisy chain is associated with this debug connection.  This option
// can be omitted on targets which have one TAP.  Note that TAPs are
// numbered from 1-N, with TAP 1 being the one whose TDO is connected
// to the MEP probe.
//
//    eo Ice_JTAG_TAP_Select = <num>

eo Ice_JTAG_TAP_Select = 1

// The  Ice_Multi_Session  option specifies whether the probe should accept
// multiple simultaneous debugger connections. This options needs to be set
// on target boards which have multiple cores that you wish to debug at the
// same time.  If multi-core debugger is not required, this option can be
// safely omitted. 
//
// eo Ice_Multi_Session = on


// Flash Initialization
//
// TO DO #5 --  If your target board requires any special initialization
//              commands to prepare for running the targetflash programming
//              utility, add those commands here.
//
//              example:  ea FLASH_INIT ew 0xa0020800 = 0x10101010; ew 0xa0020818 = 0x10101010

ea FLASH_INIT  /* nothing special required */


// Physical Memory Configuration
// =============================

mc *:P, inv     // start with all *physical* memory (*:P) marked as invalid

// TO DO #1 -- Change the address range(s) below to match the  *physical*
//             address ranges of your ROM/flash and RAM areas.  Add more
//             MC commands as necessary for each memory mapped area.
//
// WARNING:  DO NOT confuse virtual (MVA) addresses with physical space.
//           Make sure to use physical addresses in the MC table.
//
// EXAMPLE:
//
//     mc  ________:P  ________:P,  PWE, JAM, RW    // DRAM
//     mc  ________:P  ________:P,  PWD, JAM, RO    // Flash or ROM
//     mc  ________:P  ________:P,  PWD, JAM, RW    // Peripheral registers
//
// Note that if your boot code remaps physical memory, then the MC table
// should reflect the mapping that is in effect for the code you are trying
// to debug.  When debugging boot code in flash, MC should match the mapping
// in effect when booting.  When debugging code in RAM, MC should match the
// mapping in effect when running code from RAM.
//
// Address Range          PWE  Access
// ---------------------- ---- -------
// Q0
mc 0x00000000:P 0x0001bfff:P, PWD, JAM, RO, DW=16   // GPMC CS0 ROM
mc 0x04000000:P 0x0401bfff:P, PWD, JAM, RO, DW=16   // GPMC CS0 remapped
mc 0x20000000:P 0x2bffffff:P, PWD, JAM, RO, DW=16   // PoP NAND Flash
mc 0x2c000000:P 0x2c0003ff:P, PWD, JAM, RO, DW=16   // Ethernet MAC/PHY

// Q1 (1GB) 0x40000000 - 0x7fffffff
// On-chip memory
mc 0x40000000:P 0x40013fff:P, PWE, JAM, RO          // Reserved
mc 0x40014000:P 0x4001bfff:P, PWE, JAM, RO          // Boot ROM internal
mc 0x40200000:P 0x4020ffff:P, PWE, JAM, RW          // SRAM internal
mc 0x40210000:P 0x47afffff:P, PWE, JAM, RW          // Reserved
// L4 interconnects
// L4-Core (0x48000000 - 0x48ffffff)
mc 0x48002000:P 0x48002fff:P, PWE, JAM, RW          // SCM - Module
mc 0x48003000:P 0x48003fff:P, PWE, JAM, RW          // SCM - L4 interconnect
mc 0x48004000:P 0x48005fff:P, PWE, JAM, RW          // CM - Module region A
mc 0x48006000:P 0x480067ff:P, PWE, JAM, RW          // CM - Module region B
mc 0x48006800:P 0x48006fff:P, PWE, JAM, RW          // Reserved
mc 0x48007000:P 0x48007fff:P, PWE, JAM, RW          // CM - L4 interconnect
mc 0x48008000:P 0x4803ffff:P, PWE, JAM, RW          // Reserved
mc 0x48040000:P 0x480407ff:P, PWE, JAM, RW          // L4-Core conf - Address/protection (A/P)
mc 0x48040800:P 0x48040fff:P, PWE, JAM, RW          // L4-Core conf - Initiator port (IP)
mc 0x48041000:P 0x48041fff:P, PWE, JAM, RW          // L4-Core conf - Link agent (LA)
mc 0x48042000:P 0x4804fbfe:P, PWE, JAM, RW          // Reserved
mc 0x4804fbff:P 0x4804ffff:P, PWE, JAM, RW          // DSI
mc 0x48050000:P 0x480503ff:P, PWE, JAM, RW          // Display subsystem top
mc 0x48050400:P 0x480507ff:P, PWE, JAM, RW          // Display controller
mc 0x48050800:P 0x48050bff:P, PWE, JAM, RW          // Display subsystem - RFBI
mc 0x48050C00:P 0x48050fff:P, PWE, JAM, RW          // Display subsystem - Video encorder
mc 0x48051000:P 0x48051fff:P, PWE, JAM, RW          // Display subsystem - L4 interconnect
mc 0x48052000:P 0x4805ffff:P, PWE, JAM, RW          // Reserved
mc 0x48056000:P 0x48056fff:P, PWE, JAM, RW          // sDMA - Module
mc 0x48057000:P 0x48057fff:P, PWE, JAM, RW          // sDMA - L4 interconnect
mc 0x48058000:P 0x4805ffff:P, PWE, JAM, RW          // Reserved
mc 0x48060000:P 0x48060fff:P, PWE, JAM, RW          // I2C3 - Module
mc 0x48061000:P 0x48061fff:P, PWE, JAM, RW          // I2C3 - L4 interconnect
mc 0x48062000:P 0x48062fff:P, PWE, JAM, RW          // USBTLL - Module
mc 0x48063000:P 0x48063fff:P, PWE, JAM, RW          // USBTLL - L4 interconnect
mc 0x48064000:P 0x48064fff:P, PWE, JAM, RW          // HS USB Host - Module
mc 0x48065000:P 0x48065fff:P, PWE, JAM, RW          // HS USB Host - L4 interconnect
mc 0x48066000:P 0x48069fff:P, PWE, JAM, RW          // Reserved
mc 0x4806a000:P 0x4806afff:P, PWE, JAM, RW          // UART1 - Module
mc 0x4806b000:P 0x4806bfff:P, PWE, JAM, RW          // UART1 - L4 interconnect
mc 0x4806c000:P 0x4806cfff:P, PWE, JAM, RW          // UART2 - Module
mc 0x4806d000:P 0x4806dfff:P, PWE, JAM, RW          // UART2 - L4 interconnect
mc 0x4806e000:P 0x4806ffff:P, PWE, JAM, RW          // Reserved
mc 0x48070000:P 0x48070fff:P, PWE, JAM, RW          // I2C1 - Module
mc 0x48071000:P 0x48071fff:P, PWE, JAM, RW          // I2C1 - L4 interconnect
mc 0x48072000:P 0x48072fff:P, PWE, JAM, RW          // I2C2 - Module
mc 0x48073000:P 0x48073fff:P, PWE, JAM, RW          // I2C2 - L4 interconnect
mc 0x48074000:P 0x48074fff:P, PWE, JAM, RW          // McBSP1 - Module
mc 0x48075000:P 0x48075fff:P, PWE, JAM, RW          // McBSP1 - L4 interconnect
mc 0x48076000:P 0x48085fff:P, PWE, JAM, RW          // Reserved
mc 0x48086000:P 0x48086fff:P, PWE, JAM, RW          // GPTIMER10 - Module
mc 0x48087000:P 0x48087fff:P, PWE, JAM, RW          // GPTIMER10 - L4 interconnect
mc 0x48088000:P 0x48088fff:P, PWE, JAM, RW          // GPTIMER11 - Module
mc 0x48089000:P 0x48089fff:P, PWE, JAM, RW          // GPTIMER11 - L4 interconnect
mc 0x4808a000:P 0x48093fff:P, PWE, JAM, RW          // Reserved
mc 0x48094000:P 0x48094fff:P, PWE, JAM, RW          // Mailbox - Module
mc 0x48095000:P 0x48095fff:P, PWE, JAM, RW          // Mailbox - L4 interconnect
mc 0x48096000:P 0x48096fff:P, PWE, JAM, RW          // McBSP5 - Module
mc 0x48097000:P 0x48097fff:P, PWE, JAM, RW          // McBSO5 - L4 interconnect
mc 0x48098000:P 0x48098fff:P, PWE, JAM, RW          // McSPI1 - Module
mc 0x48099000:P 0x48099fff:P, PWE, JAM, RW          // McSPI1 - L4 interconnect
mc 0x4809a000:P 0x4809afff:P, PWE, JAM, RW          // McSPI2 - Module
mc 0x4809b000:P 0x4809bfff:P, PWE, JAM, RW          // McSPI2 - L4 interconnect
mc 0x4809c000:P 0x4809cfff:P, PWE, JAM, RW          // MMC/SD/SDIO1 - Module
mc 0x4809d000:P 0x4809dfff:P, PWE, JAM, RW          // MMC/SD.SDIO1 - L4 interconnect
mc 0x4809e000:P 0x480aafff:P, PWE, JAM, RW          // Reserved
mc 0x480ab000:P 0x480abfff:P, PWE, JAM, RW          // HS USB OTG - Module
mc 0x480ac000:P 0x480acfff:P, PWE, JAM, RW          // HS USB OTG - L4 interconnect
mc 0x480ad000:P 0x480adfff:P, PWE, JAM, RW          // MMC/SD/SDIO3 - Module
mc 0x480ae000:P 0x480aefff:P, PWE, JAM, RW          // MMC/SD.SDIO3 - L4 interconnect
mc 0x480af000:P 0x480b1fff:P, PWE, JAM, RW          // Reserved
mc 0x480b2000:P 0x480b2fff:P, PWE, JAM, RW          // HDQ/1-Wire - Module
mc 0x480b3000:P 0x480b3fff:P, PWE, JAM, RW          // HDQ/1-Wire - L4 interconnect
mc 0x480b4000:P 0x480b4fff:P, PWE, JAM, RW          // MMC/SD/SDIO2 - Module
mc 0x480b5000:P 0x480b5fff:P, PWE, JAM, RW          // MMC/SD.SDIO2 - L4 interconnect
mc 0x480b6000:P 0x480b6fff:P, PWE, JAM, RW          // ICR MPU port - Module
mc 0x480b7000:P 0x480b7fff:P, PWE, JAM, RW          // ICR MPU port - L4 interconnect
mc 0x480b8000:P 0x480b8fff:P, PWE, JAM, RW          // McSPI3 - Module
mc 0x480b9000:P 0x480b9fff:P, PWE, JAM, RW          // McSPI3 - L4 interconnect
mc 0x480ba000:P 0x480bafff:P, PWE, JAM, RW          // McSPI4 - Module
mc 0x480bb000:P 0x480bbfff:P, PWE, JAM, RW          // McSPI4 - L4 interconnect
mc 0x480bc000:P 0x480bffff:P, PWE, JAM, RW          // Camera ISP - Module
mc 0x480c0000:P 0x480c0fff:P, PWE, JAM, RW          // Camera ISP - L4 interconnect
mc 0x480c1000:P 0x480c8fff:P, PWE, JAM, RW          // Reserved
mc 0x480c9000:P 0x480c9fff:P, PWE, JAM, RW          // SR1 - Module
mc 0x480ca000:P 0x480cafff:P, PWE, JAM, RW          // SR1 - L4 interconnect
mc 0x480cb000:P 0x480cbfff:P, PWE, JAM, RW          // SR2 - Module
mc 0x480cc000:P 0x480ccfff:P, PWE, JAM, RW          // SR2 - L4 interconnect
mc 0x480cd000:P 0x480cdfff:P, PWE, JAM, RW          // ICR modem port - Module
mc 0x480ce000:P 0x480cefff:P, PWE, JAM, RW          // ICR modem port - L4 interconnect
mc 0x480cf000:P 0x482fffff:P, PWE, JAM, RW          // Reserved
// L4-Wakeup (0x48300000 - 0x4833ffff)
mc 0x48300000:P 0x48305fff:P, PWE, JAM, RW          // Reserved
mc 0x48306000:P 0x48307fff:P, PWE, JAM, RW          // PRM - Module region A
mc 0x48308000:P 0x483087ff:P, PWE, JAM, RW          // PRM - Module region B
mc 0x48308800:P 0x48308fff:P, PWE, JAM, RW          // Reserved
mc 0x48309000:P 0x48309fff:P, PWE, JAM, RW          // PRM - L4 interconnect
mc 0x4830a000:P 0x4830ffff:P, PWE, JAM, RW          // Reserved
mc 0x48310000:P 0x48310fff:P, PWE, JAM, RW          // GPIO1 - Module
mc 0x48311000:P 0x48311fff:P, PWE, JAM, RW          // GPIO1 - L4 interconnect
mc 0x48312000:P 0x48313fff:P, PWE, JAM, RW          // Reserved
mc 0x48314000:P 0x48314fff:P, PWE, JAM, RW          // WDT2 - Module
mc 0x48315000:P 0x48315fff:P, PWE, JAM, RW          // WDT2 - L4 interconnect
mc 0x48316000:P 0x48317fff:P, PWE, JAM, RW          // Reserved
mc 0x48318000:P 0x48318fff:P, PWE, JAM, RW          // GPTIMER1 - Module
mc 0x48319000:P 0x48319fff:P, PWE, JAM, RW          // GPTIMER1 - L4 interconnect
mc 0x4831a000:P 0x4831ffff:P, PWE, JAM, RW          // Reserved
mc 0x48320000:P 0x48320fff:P, PWE, JAM, RW          // 32KTIMER - Module
mc 0x48321000:P 0x48321fff:P, PWE, JAM, RW          // 32KTIMER - L4 interconnect
mc 0x48322000:P 0x48327fff:P, PWE, JAM, RW          // Reserved
mc 0x48328000:P 0x483287ff:P, PWE, JAM, RW          // L4-Wakeup config - AP
mc 0x48328800:P 0x48328fff:P, PWE, JAM, RW          // L4-Wakeup config - IP L4-Core
mc 0x48329000:P 0x48329fff:P, PWE, JAM, RW          // L4-Wakeup config - LA
mc 0x4832a000:P 0x4832a7ff:P, PWE, JAM, RW          // L4-Wakeup config - IP L4-Emu
mc 0x4832a800:P 0x4833ffff:P, PWE, JAM, RW          // Reserved
// L4-Per (0x49000000 - 0x490fffff)
mc 0x49000000:P 0x490007ff:P, PWE, JAM, RW          // L4-Per config - AP
mc 0x49000800:P 0x49000fff:P, PWE, JAM, RW          // L4-Per config - IP
mc 0x49001000:P 0x49001fff:P, PWE, JAM, RW          // L4-Per config - LA
mc 0x49002000:P 0x4901ffff:P, PWE, JAM, RW          // Reserved
mc 0x49020000:P 0x49020fff:P, PWE, JAM, RW          // UART3 - Module
mc 0x49021000:P 0x49021fff:P, PWE, JAM, RW          // UART3 - L4 interconnect
mc 0x49022000:P 0x49022fff:P, PWE, JAM, RW          // McBSP2 - Module
mc 0x49023000:P 0x49023fff:P, PWE, JAM, RW          // McBSP2 - L4 interconnect
mc 0x49024000:P 0x49024fff:P, PWE, JAM, RW          // McBSP3 - Module
mc 0x49025000:P 0x49025fff:P, PWE, JAM, RW          // McBSP3 - L4 interconnect
mc 0x49026000:P 0x49026fff:P, PWE, JAM, RW          // McBSP4 - Module
mc 0x49027000:P 0x49027fff:P, PWE, JAM, RW          // McBSP4 - L4 interconnect
mc 0x49028000:P 0x49028fff:P, PWE, JAM, RW          // McBSP2(sidetone) - Module
mc 0x49029000:P 0x49029fff:P, PWE, JAM, RW          // McBSP2(sidetone) - L4 interconnect
mc 0x4902a000:P 0x4902afff:P, PWE, JAM, RW          // McBSP3(sidetone) - Module
mc 0x4902b000:P 0x4902bfff:P, PWE, JAM, RW          // McBSP3(sidetone) - L4 interconnect
mc 0x4902c000:P 0x4902ffff:P, PWE, JAM, RW          // Reserved
mc 0x49030000:P 0x49030fff:P, PWE, JAM, RW          // WDT3 - Module
mc 0x49031000:P 0x49031fff:P, PWE, JAM, RW          // WDT3 - L4 interconnect
mc 0x49032000:P 0x49032fff:P, PWE, JAM, RW          // GPTIMER2 - Module
mc 0x49033000:P 0x49033fff:P, PWE, JAM, RW          // GPTIMER2 - L4 interconnect
mc 0x49034000:P 0x49034fff:P, PWE, JAM, RW          // GPTIMER3 - Module
mc 0x49035000:P 0x49035fff:P, PWE, JAM, RW          // GPTIMER3 - L4 interconnect
mc 0x49036000:P 0x49036fff:P, PWE, JAM, RW          // GPTIMER4 - Module
mc 0x49037000:P 0x49037fff:P, PWE, JAM, RW          // GPTIMER4 - L4 interconnect
mc 0x49038000:P 0x49038fff:P, PWE, JAM, RW          // GPTIMER5 - Module
mc 0x49039000:P 0x49039fff:P, PWE, JAM, RW          // GPTIMER5 - L4 interconnect
mc 0x4903a000:P 0x4903afff:P, PWE, JAM, RW          // GPTIMER6 - Module
mc 0x4903b000:P 0x4903bfff:P, PWE, JAM, RW          // GPTIMER6 - L4 interconnect
mc 0x4903c000:P 0x4903cfff:P, PWE, JAM, RW          // GPTIMER7 - Module
mc 0x4903d000:P 0x4903dfff:P, PWE, JAM, RW          // GPTIMER7 - L4 interconnect
mc 0x4903e000:P 0x4903efff:P, PWE, JAM, RW          // GPTIMER8 - Module
mc 0x4903f000:P 0x4903ffff:P, PWE, JAM, RW          // GPTIMER8 - L4 interconnect
mc 0x49040000:P 0x49040fff:P, PWE, JAM, RW          // GPTIMER9 - Module
mc 0x49041000:P 0x49041fff:P, PWE, JAM, RW          // GPTIMER9 - L4 interconnect
mc 0x49042000:P 0x49042fff:P, PWE, JAM, RW          // UART4 - Module
mc 0x49043000:P 0x49043fff:P, PWE, JAM, RW          // UART4 - L4 interconnect
mc 0x49044000:P 0x4904ffff:P, PWE, JAM, RW          // Reserved
mc 0x49050000:P 0x49050fff:P, PWE, JAM, RW          // GPIO2 - Module
mc 0x49051000:P 0x49051fff:P, PWE, JAM, RW          // GPIO2 - L4 interconnect
mc 0x49052000:P 0x49052fff:P, PWE, JAM, RW          // GPIO3 - Module
mc 0x49053000:P 0x49053fff:P, PWE, JAM, RW          // GPIO3 - L4 interconnect
mc 0x49054000:P 0x49054fff:P, PWE, JAM, RW          // GPIO4 - Module
mc 0x49055000:P 0x49055fff:P, PWE, JAM, RW          // GPIO4 - L4 interconnect
mc 0x49056000:P 0x49056fff:P, PWE, JAM, RW          // GPIO5 - Module
mc 0x49057000:P 0x49057fff:P, PWE, JAM, RW          // GPIO5 - L4 interconnect
mc 0x49058000:P 0x49058fff:P, PWE, JAM, RW          // GPIO6 - Module
mc 0x49059000:P 0x49059fff:P, PWE, JAM, RW          // GPIO6 - L4 interconnect
mc 0x4905a000:P 0x490fffff:P, PWE, JAM, RW          // Reserved
// SGX
mc 0x50000000:P 0x5000ffff:P, PWE, JAM, RW          // SGX
mc 0x50010000:P 0x53ffffff:P, PWE, JAM, RW          // Reserved
// L4-Emu (0x54000000 - 0x547fffff)
mc 0x54000000:P 0x54005fff:P, PWE, JAM, RW          // Reserved
mc 0x54006000:P 0x540067ff:P, PWE, JAM, RW          // L4-Emu config - AP
mc 0x54006800:P 0x54006fff:P, PWE, JAM, RW          // L4-Emu config - IP L4-Core
mc 0x54007000:P 0x54007fff:P, PWE, JAM, RW          // L4-Emu config - LA
mc 0x54008000:P 0x540087ff:P, PWE, JAM, RW          // L4-Emu config - IP DAP
mc 0x54008800:P 0x5400ffff:P, PWE, JAM, RW          // Reserved
mc 0x54010000:P 0x54017fff:P, PWE, JAM, RW          // MPU emulation - Module
mc 0x54018000:P 0x54018fff:P, PWE, JAM, RW          // MPU emulation - L4 interconnect
mc 0x54019000:P 0x54019fff:P, PWE, JAM, RW          // TPIU - Module
mc 0x5401a000:P 0x5401afff:P, PWE, JAM, RW          // TPIU - L4 interconnect
mc 0x5401b000:P 0x5401bfff:P, PWE, JAM, RW          // ETB - Module
mc 0x5401c000:P 0x5401cfff:P, PWE, JAM, RW          // ETB - L4 interconnect
mc 0x5401d000:P 0x5401dfff:P, PWE, JAM, RW          // DAPCTL - Module
mc 0x5401e000:P 0x5401efff:P, PWE, JAM, RW          // DAPCTL - L4 interconnect
mc 0x5401f000:P 0x5401ffff:P, PWE, JAM, RW          // SDTI - L4 interconnect
mc 0x54020000:P 0x544fffff:P, PWE, JAM, RW          // Reserved
mc 0x54500000:P 0x5450ffff:P, PWE, JAM, RW          // SDTI - SDTI module (config)
mc 0x54510000:P 0x545fffff:P, PWE, JAM, RW          // Reserved
mc 0x54600000:P 0x546fffff:P, PWE, JAM, RW          // SDTI - SDTI module (window)
mc 0x54700000:P 0x54705fff:P, PWE, JAM, RW          // Reserved
mc 0x54706000:P 0x54707fff:P, PWE, JAM, RW          // PRM - Module region A
mc 0x54708000:P 0x547087ff:P, PWE, JAM, RW          // PRM - Module region B
mc 0x54708800:P 0x54708fff:P, PWE, JAM, RW          // Reserved
mc 0x54709000:P 0x54709fff:P, PWE, JAM, RW          // PRM - L4 interconnect
mc 0x5470a000:P 0x5470ffff:P, PWE, JAM, RW          // Reserved
mc 0x54710000:P 0x54710fff:P, PWE, JAM, RW          // GPIO1 - Module
mc 0x54711000:P 0x54711fff:P, PWE, JAM, RW          // GPIO1 - L4 interconnect
mc 0x54712000:P 0x54713fff:P, PWE, JAM, RW          // Reserved
mc 0x54714000:P 0x54714fff:P, PWE, JAM, RW          // WDT2 - Module
mc 0x54715000:P 0x54715fff:P, PWE, JAM, RW          // WDT2 - L4 interconnect
mc 0x54716000:P 0x54717fff:P, PWE, JAM, RW          // Reserved
mc 0x54718000:P 0x54718fff:P, PWE, JAM, RW          // GPTIMER1 - Module
mc 0x54719000:P 0x54719fff:P, PWE, JAM, RW          // GPTIMER1 - L4 interconnect
mc 0x5471a000:P 0x5471ffff:P, PWE, JAM, RW          // Reserved
mc 0x54720000:P 0x54720fff:P, PWE, JAM, RW          // 32KTIMER - Module
mc 0x54721000:P 0x54721fff:P, PWE, JAM, RW          // 32KTIMER - L4 interconnect
mc 0x54722000:P 0x54727fff:P, PWE, JAM, RW          // Reserved
mc 0x54728000:P 0x547287ff:P, PWE, JAM, RW          // L4-Wakeup config - AP
mc 0x54728800:P 0x54728fff:P, PWE, JAM, RW          // L4-Wakeup config - IP L4-Core
mc 0x54729000:P 0x54729fff:P, PWE, JAM, RW          // L4-Wakeup config - LA
mc 0x5472a000:P 0x5472a7ff:P, PWE, JAM, RW          // L4-Wakeup config - IP L4-Emu
mc 0x5472a800:P 0x547fffff:P, PWE, JAM, RW          // Reserved
// IVA2.2 subsystem
mc 0x5c000000:P 0x5effffff:P, PWE, JAM, RW          // IVA2.2 subsystem
mc 0x5f000000:P 0x5fffffff:P, PWE, JAM, RW          // Reserved
// L3 interconnect
mc 0x68000000:P 0x680143ff:P, PWE, JAM, RW          // L3
mc 0x68014400:P 0x68ffffff:P, PWE, JAM, RW          // Reserved
mc 0x6c000000:P 0x6cffffff:P, PWE, JAM, RW          // SMS registers
mc 0x6d000000:P 0x6dffffff:P, PWE, JAM, RW          // SDRC registers
mc 0x6e000000:P 0x6effffff:P, PWE, JAM, RW          // GPMC registers
mc 0x6f000000:P 0x6fffffff:P, PWE, JAM, RW          // Reserved
// SDRC/SMS
mc 0x70000000:P 0x7fffffff:P, PWE, JAM, RW          // SDRC/SMS virtual address space0

// Q2
mc 0x80000000:P 0x9fffffff:P, PWD, JAM, RW, DW=16   // CS0 - SDRAM
mc 0xa0000000:P 0xbfffffff:P, PWD, JAM, RW, DW=16   // CS1 - SDRAM

// Q3
mc 0xc0000000:P 0xdfffffff:P, PWE, JAM, RW          // Reserved
mc 0xe0000000:P 0xefffffff:P, PWE, JAM, RW          // SDRC/SMS virtual address space1

//        ____User Supplied Setup Commands Go Here____

// TO DO #2 -- If your target board requires any special MEP settings
//             (e.g. special JTAG initialization), add the commands to
//             make those settings here.


// End of initial one-time only setup script.  In non-intrusive connect
// mode, exit at this point.

if (@.4$INIT_TYPE != 0) {dv "Non-intrusive connect mode\n"; goto EXIT}

// TO DO #3 -- Comment out all but one of the next three commands to
//             control IF and HOW the target is initialized when the
//             debugger is launched.  If no reset or target initialization
//             is needed then all these can be left commented out.

TI
//   RTI
//   RTNI

:EXIT
dv "Finished reading $$#.\n"
return

//___________________________________________________________________
::DO_RTNI  // Reset Target with No Initialization.

    // Normally an  rt  command is sufficient, but it may be necessary
    // to slow down the JTAG clock first, depending on the affect of
    // reset on the processor.

    dv "Executing RTNI script function\n"
	eo Ice_Reset_Delay = 1000
    rt
    return

//___________________________________________________________________
::DO_RTI   // Reset Target and Initialize.

    // Note that it may be necessary to slow down the JTAG clock first, 
    // depending on the affect of reset on the processor.

    dv "Executing RTI script function\n"
	eo Ice_Reset_Delay = 1000
    rt
    TI	// call script DO_TI function
    return

//___________________________________________________________________
::DO_TI  // Target Initialize.

    if (@$trgt_cpu_state != $tcs.halt) { dv "Target Initialization commands skipped due to CPU state\n"; doq TCS; return }
    dv "Initializing target...\n"

    dv "Watchdog disable\n"
    ew 0x48004C10:P = 0x00000020                // CM_ICLKEN_WKUP
    ew 0x48004C00:P = 0x00000020                // CM_FCLKEN_WKUP

    :label_wd_dis_1
    if ((@0x48004C20 & 0x00000020) != 0) {goto label_wd_dis_1}

    :label_wd_dis_2
    if ((@0x48314014 & 0x00000001) == 0) {goto label_wd_dis_2}
    ew 0x48314048:P = 0x0000AAAA                // WSPR

    :label_wd_dis_3
    if ((@0x48314034 & 0x00000010) != 0) {goto label_wd_dis_3}
    ew 0x48314048:P = 0x00005555                // WSPR

    :label_wd_dis_4
    if ((@0x48314034 & 0x00000010) != 0) {goto label_wd_dis_4}

    /* ----------------------------------------------------- */
    dv "Initialize Power and Sleep Controller\n"

    // Turn on CORE power domain (CPU *should* default to on)
    ew $Clock_Control_Reg_CM_v = @0x48306AE0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48306A00:P = @$Clock_Control_Reg_CM_v

    // Turn on MPU power domain (CPU *should* default to on)
    ew $Clock_Control_Reg_CM_v = @0x483069E0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48306900:P = @$Clock_Control_Reg_CM_v

    // Turn on IVA2 power domain 
    ew $Clock_Control_Reg_CM_v = @0x483060E0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48306000:P = @$Clock_Control_Reg_CM_v

    // Turn on OCP System Registers power domain 
    ew $Clock_Control_Reg_CM_v = @0x483068E0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48306800:P = @$Clock_Control_Reg_CM_v

    // Turn on GFX power domain 
    ew $Clock_Control_Reg_CM_v = @0x48306BE0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48306B00:P = @$Clock_Control_Reg_CM_v

    // Turn on DSS power domain 
    ew $Clock_Control_Reg_CM_v = @0x48306EE0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48306E00:P = @$Clock_Control_Reg_CM_v

    // Turn on CAM power domain 
    ew $Clock_Control_Reg_CM_v = @0x48306FE0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48306F00:P = @$Clock_Control_Reg_CM_v

    // Turn on PER power domain 
    ew $Clock_Control_Reg_CM_v = @0x483070E0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48307000:P = @$Clock_Control_Reg_CM_v

    // Turn on EMU power domain 
    ew $Clock_Control_Reg_CM_v = @0x483071E0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48307100:P = @$Clock_Control_Reg_CM_v

    // Turn on NEON power domain 
    ew $Clock_Control_Reg_CM_v = @0x483073E0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48307300:P = @$Clock_Control_Reg_CM_v

    // Turn on USB Host power domain 
    ew $Clock_Control_Reg_CM_v = @0x483074E0
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x00000003
    ew 0x48307400:P = @$Clock_Control_Reg_CM_v

    /* ----------------------------------------------------- */
    dv "Setup ClockConfig\n"
    ew $Clock_Control_Reg_CM_v = @0x48004D00    // Clock_Control_Reg_CM
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xfffffff8
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x05
    ew 0x48004D00:P = @$Clock_Control_Reg_CM_v  // Clock_Control_Reg_CM

    :label_DPLL3
    if ((@0x48004D20 & 0x00000001) == 0x00000001) {goto label_DPLL3}

    ew $Clock_Control_Reg_CM_v = @0x48004904    // Put MPU in low power bypass  (DPLL1)
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xfffffff8
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x05
    ew 0x48004904:P = @$Clock_Control_Reg_CM_v

    // Wait for bypass mode
    :label_DPLL1
    if ((@0x48004924 & 0x00000001) == 0x00000001) {goto label_DPLL1}

    ew $Clock_Control_Reg_CM_v = @0x48004D00    // Put peripheral bus in low power stop mode  (DPLL4)
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xfff8ffff
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x10000
    ew 0x48004D00:P = @$Clock_Control_Reg_CM_v

    // Wait for bypass mode
    :label_DPLL4
    if ((@0x48004924 & 0x00000002) == 0x00000002) {goto label_DPLL4}

    ew $Clock_Control_Reg_CM_v = @0x48004D04    // Put Per2 in low power stop mode  (DPLL5)
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xfffffff8
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x1
    ew 0x48004D04:P = @$Clock_Control_Reg_CM_v

    // Wait for bypass mode
    :label_DPLL5
    if ((@0x48004D24 & 0x00000001) == 0x00000001) {goto label_DPLL5}

    dv "Select SystemClock\n"
    ew 0x48306D40:P = 0x00000003                // PRM_CLKSEL
    ew 0x48307270:P = 0x00000080                // Sys Clock Divider
    ew 0x48004A40:P = 0x0000000a                // CM_CLKSEL_CORE

    /* ----------------------------------------------------- */
    dv "Configure DPLLS\n"

    ew 0x48004940:P = 0x0013E80C                // Set CM_CLKSEL1_PLL_MPU register
    ew 0x48004944:P = 0x1                       // Set CM_CLKSEL2_PLL_MPU register
    ew 0x48004904:P = 0x00000037                // Set CM_CLKEN_PLL_MPU register

    // Set CM_CLKSEL1_PLL register
    ew 0x48004D40:P = 0x094C0C00

    // Set CM_CLKEN_PLL register
    ew $Clock_Control_Reg_CM_v = @0x48004D00
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xffffff08
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x30
    ew 0x48004D00:P = @$Clock_Control_Reg_CM_v 

    :label_CLKEN_PLL
    if ((@0x48004D20 & 0x00000001) == 0x00000001) {goto label_CLKEN_PLL}

    // Set CM_CLKSEL1_EMU register
    ew 0x48005140:P = 0x03020A50

    /* ----------------------------------------------------- */
    dv "Configure peripheral bus\n"

    ew 0x48004D44:P = 0x0483600C               // Set CM_CLKSEL2_PLL register
    ew 0x48004040:P = 0x00082800

    // Set CM_CLKEN_PLL register
    ew $Clock_Control_Reg_CM_v = @0x48004D00
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xff0fffff
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x300000
    ew 0x48004D00:P = @$Clock_Control_Reg_CM_v

    // Set CM_CLKSEL3_PLL register
    ew 0x48004D48:P  =  0x9

    // Set CM_CLKSEL_DSS register
    ew 0x48004E40:P = 0x00001009

    // Set CM_CLKSEL_CAM register
    ew 0x48004F40:P = 0x00000004

    // Set CM_CLKSEL1_EMU register
    ew 0x48005140:P = 0x03020A50

    // Lock core
    ew $Clock_Control_Reg_CM_v = @0x48004D00
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xfffffff8
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x07
    ew 0x48004D00:P = @$Clock_Control_Reg_CM_v

    // Wait for lock
    :label_CORElock
    if ((@0x48004D20 & 0x00000001) != 0x00000001) {goto label_CORElock}

    // Lock MPU
    ew $Clock_Control_Reg_CM_v = @0x48004904
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xfffffff8
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x07
    ew 0x48004904:P = @$Clock_Control_Reg_CM_v

    // Wait for lock
    :label_MPUlock
    if ((@0x48004924 & 0x00000001) != 0x00000001) {goto label_MPUlock}

    // Lock Peripheral bus
    ew $Clock_Control_Reg_CM_v = @0x48004D00
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v & 0xfff8ffff
    ew $Clock_Control_Reg_CM_v = @$Clock_Control_Reg_CM_v | 0x070000
    ew 0x48004D00:P = @$Clock_Control_Reg_CM_v

    // Wait for lock
    :label_PeripheralLock
    if ((@0x48004D20 & 0x00000002) != 0x00000002) {goto label_PeripheralLock}

    // Set CM_FCLKEN1_CORE register
    ew 0x48004A00:P = 0xFFFFFFFF

    // Set CM_ICLKEN1_CORE register
    ew 0x48004A10:P = 0xFFFFFFFF

    // Set CM_ICLKEN2_CORE register
    ew 0x48004A14:P = 0xFFFFFFFF

    // Set CM_FCLKEN_WKUP register
    ew 0x48004C00:P = 0xFFFFFFFF

    // Set CM_ICLKEN_WKUP register
    ew 0x48004C10:P = 0xFFFFFFFF

    // Set CM_FCLKEN_PER register
    ew 0x48005000:P = 0xFFFFFFFF

    // Set CM_ICLKEN_PER register
    ew 0x48005010:P = 0xFFFFFFFF

    // Set CM_FCLKEN_DSS register
    ew 0x48004E00:P = 0x00000007

    // Set CM_ICLKEN_DSS register
    ew 0x48004E10:P = 0x00000001

    //  Memory Controller Setup
    //
    // TO DO #4 -- If your board has a different memory configuration than
    //             the reference board, then you may need to adapt the
    //             memory controller initialization script accordingly.
    //             These settings should match the settings used by your
    //             boot code during its hardware initialization phase.

    dv "set reg:cpsr\n"
    ew cpsr = 0x200001d3                                // switch CPU to ARM mode

    // SDRAM
    dv "Initialize SDRAM Controller\n"

    //ew 0x6d000010:P = 0x00000012                      // SDRC_SYSCONFIG = SOFTRESET
    ew 0x6d000010:P = 0x00000002                        // SDRC_SYSCONFIG = SOFTRESET

    :label_sdramresetok1
    if ((@0x6d000014 & 0x00000001) == 0) {goto label_sdramresetok1}

    //ew 0x6d000010:P = 0x00000000                        // SDRC_SYSCONFIG = ~SOFTRESET
    ew 0x6d000010:P = 0x00000010                        // SDRC_SYSCONFIG = ~SOFTRESET|SMARTIDLE

    ew $SDRC_EMR2_v = 0x00000020
    ew $SDRC_RFR_CTRL_v = 0x00005d01

    /*for 16-bit mode*/
    ew $SDRC_MCFG0_v = 0x03588089
    ew $SDRC_MCFG1_v = 0x03580089
    ew $SDRC_SHARING_v = 0x00000700

    /* All values optimized for 200MHz for Hynix device with AM37x*/
    ew $SDRC_ACTIM_CTRLA_v = 0x92e1c4c6
    ew $SDRC_ACTIM_CTRLB_v = 0x0002111c

    /*Configure only memory on CS0*/

    /* Disable power saving mode */
    ew 0x6d000070:P = @0x6d000070 & 0xfffffffb          // SDRC_POWER

    ew 0x6d000080:P = @$SDRC_MCFG0_v                    // SDRC_MCFG_0
    ew 0x6d0000b0:P = @$SDRC_MCFG1_v                    // SDRC_MCFG_1
    ew 0x6d000044:P = @$SDRC_SHARING_v                  // SDRC_SHARING

    w 200                                               // dummy wait

    ew 0x6d0000a4:P = @$SDRC_RFR_CTRL_v                 // SDRC_RFR_CTRL_0
    ew 0x6d0000d4:P = @$SDRC_RFR_CTRL_v                 // SDRC_RFR_CTRL_1

    /* SDRC_ACTIM_CTRLA register (optimized for clk = 166MHz -> safe configuration)  */
    ew 0x6d00009c:P = @$SDRC_ACTIM_CTRLA_v              // SDRC_ACTIM_CTRLA_0
    ew 0x6d0000c4:P = @$SDRC_ACTIM_CTRLA_v              // SDRC_ACTIM_CTRLA_1

    /* SDRC_ACTIM_CTRLB register (optimized for clk = 166MHz) */
    ew 0x6d0000a0:P = @$SDRC_ACTIM_CTRLB_v              // SDRC_ACTIM_CTRLB_0
    ew 0x6d0000c8:P = @$SDRC_ACTIM_CTRLB_v              // SDRC_ACTIM_CTRLB_1

    ew 0x6d0000A8:P = 0x00000000                        // SDRC_MANUAL_0 = 0x0:NOP
    w 100                                               // dummy wait
    ew 0x6d0000A8:P = 0x00000001                        // SDRC_MANUAL_0 = 0x1:Pre-charge
    ew 0x6d0000A8:P = 0x00000002                        // SDRC_MANUAL_0 = 0x2:Auto-refresh
    ew 0x6d0000A8:P = 0x00000002                        // SDRC_MANUAL_0 = 0x2:Auto-refresh

    ew 0x6d000084:P = 0x00000032                        // SDRC_MR_0 = CAS3, BL4

    /* Re-enable power saving mode*/
    ew 0x6d000070:P = @0x6d000070 | (0n1 << 0n2)        // SDRC_POWER

    /*DDR memory connected*/
    ew 0x6d000060:P = 0x0000000a                        // SDRC_DLLA_CTRL
    ew $sdram_lock_counter = 0

    :label_sdram1
    ew $sdram_lock_counter = @$sdram_lock_counter + 1
    if (@$sdram_lock_counter > 100) {goto label_sdram_error}
    if ((@0x6d000064 & 0x00000004) != 0x00000004) {goto label_sdram1}
    goto label_sdram_locked

    :label_sdram_error
    dv "SDRAM lock error.\n"
    goto EXIT

    :label_sdram_locked
    ew 0x6d000010:P = @0x6d000010 | (0n2 << 0n3)        // SDRC_SYSCONFIG
    ew 0x6c000010:P = @0x6c000010 | (0n2 << 0n3)        // SMS_SYSCONFIG
    ew 0x6d000070:P = @0x6d000070 | (0n1 << 0n6)        // SDRC_POWER
    ew 0x6d00008c:P = @$SDRC_EMR2_v                     // SDRC_EMR2_0
    ew 0x6d0000bc:P = @$SDRC_EMR2_v                     // SDRC_EMR2_1

    //        ____User Supplied Target Init Commands Go Here____

    dv "Initializing target done.\n"
    return

//___________________________________________________________________

// <eof>
